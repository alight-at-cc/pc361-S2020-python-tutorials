\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage[pdftex]{graphicx}
\usepackage{outlines}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{minted}
\usemintedstyle{borland}

\usepackage{draftwatermark}
\SetWatermarkScale{3.5}
\SetWatermarkText{Draft -- In Progress}

\usepackage{listings}
\lstset{language=python}

\pagestyle{plain}
\newcommand{\mvec}[1]{\mathbf{#1}}
\newcommand{\onehalf}{\frac{1}{2}}
\newcommand{\avg}[1]{\langle #1 \rangle}

\setlength\parindent{0cm}
\setlength\parskip{2mm}

\begin{document}

\begin{center}
	\LARGE  How to Avoid Feeling Constricted
	
	\normalsize  Some entry points into Python scripting for physicists \\
  %\rule{0.9\textwidth}{0.1pt}
\end{center}


\section*{Disclaimer}
This document is meant as a conceptual introduction to Python scripting.  
I am not a computer scientist or a talented code monkey.  
In fact, I'm not even a computer nerd.
Introductory computer programming was one of the most challenging courses I ever took.
I am writing these thoughts down as a person who needed to learn a distinct way of thinking in order to solve problems using a computer.
I hope it's helpful, but this document does not conform to any particular school of thought and likely is riddled with anecdotes that would be considered erroneous in one discipline or another.
Take what you will.

\section[The Zen of Python]{The Zen of Python\footnote{This public domain document is canonized as a ``Python Enhancement Proposal'' or PEP and can be found here: \url{https://www.python.org/dev/peps/pep-0020/}}}

\tt
Beautiful is better than ugly.\\
Explicit is better than implicit.\\
Simple is better than complex.\\
Complex is better than complicated.\\
Flat is better than nested.\\
Sparse is better than dense.\\
Readability counts.\\
Special cases aren't special enough to break the rules.\\
Although practicality beats purity.\\
Errors should never pass silently.\\
Unless explicitly silenced.\\
In the face of ambiguity, refuse the temptation to guess.\\
There should be one-- and preferably only one --obvious way to do it.\\
Although that way may not be obvious at first unless you're Dutch.\\
Now is better than never.\\
Although never is often better than *right* now.\\
If the implementation is hard to explain, it's a bad idea.\\
If the implementation is easy to explain, it may be a good idea.\\
Namespaces are one honking great idea -- let's do more of those!\\
\rm

Python is an open-source, ``living'' language.  
Professionals, hobbyists, and philanthropists all contribute to improve the capabilities of the code.
There is an entire culture of Pythonistas, which I know almost nothing about.
For a physicist like me, the open-source nature of the code means that there is likely someone who has already tried something similar to what I want to do who will share their work with me.
I've found the Python community to be fantastically collaborative and supportive of the open-source movement, and I encourage you to ``pay it forward'' as you develop code of your own.

The Jupyter notebook is sort of like a lab notebook with a computer console inside.  
It is a playground for testing and accomplishing computational tasks while documenting the whole thing in a nice-looking way.  
The notebook is not as fast as a compiled script (write an entire program, compile it, and then run it), but you can always migrate code from your notebook into a compiled module once it is ``production" code.

\section{How to Talk to a Computer}

The computer only does what it is told.  
It is your responsibility to understand the tools you use and what they implicitly tell the computer to do.
For example, if you tell a computer to create a list of numbers from one to ten, think about all of the possibilities:
How many numbers to you want in between one and ten?  Is the interval open or closed (i.e. does it end before ten or after ten)?  How many decimal places should you use for each number? 
You must make these choices explicitly and/or understand what the default behavior will be.  

Programming is mostly about producing, storing, moving, and connecting pieces of information.  
Each language has different systems for doing each of these tasks and different implicit behavior when not all information is specified.  
Code does not usually read like a physics argument.  
Just as mathematicians distinguish definition from equality from similarity, code must also distinguish storage from motion from connection of information.  
Symbolic representations of these tasks may look like math, but make sure you understand what a symbol means in context before you assume its function.
A prime example of this is the difference between the ``assignment'' operator and the relational equality operator.
The statement \mintinline{python}{a = 10}
stores the integer value ``10'' in a series of bytes, and uses the label ``a'' to reference that value.
The statement \mintinline{python}{a == 10}
is a functional comparison: you are telling to computer to check the bytes referenced by label ``a'' and see if the integer ``10'' is the same as what is stored there.
The computer returns either ``True'' or ``False'' depending on whether ``10'' is actually stored under the reference ``a.''

There are two basic ways to use a language like Python: 
\begin{enumerate}
	\item You can create some information and operate on it sequentially with functions or procedures that take input and generate output (``procedural" programming).
	\item You can create an information \emph{object} that has associated attributes and knows how to do certain things (``object-oriented" programming).
\end{enumerate}
You will come across examples of both styles, and I encourage you to keep your eye out for places where one might make more sense than the other.

It usually takes some iteration to learn how to tell the computer to do things.
I know that for me it took hours of expletive-shouting and head-banging before I understood how to say exactly what I wanted in C++.
The bulk of my code and my difficulty in creating it involves error checking: making sure the computer is told to do the right thing even if a user or another program is telling it misplaced or irrelevant information.
Thinking about error-checking as you design your code will help you learn how to say exactly what you mean.
Use the resources available to you to limit your frustration and speed your learning.
I highly encourage you to make use of online tutorials and to ask lots of questions.


\section{Make your Code Talk to People Too}

Python has the advantage that the syntax is designed to be readable.  
White space (tabs, spaces, etc) matters.  
If you don't follow the indentation rules, your program will not run. 
I consider this ``forced'' format to be an advantage, although some people would disagree.
Regardless of how much you think the aesthetics makes your code readable, you should get into the habit of annotating your code. 

It is usually possible to figure out \emph{what} a piece of code does, but not necessarily \emph{why} it was designed to do so.  
It is your responsibility to make sure that your peers (or your instructors) can gain some insight into your thought process by looking at your files.
Very often, the bare statements are not enough.
You must \emph{document} your code in order for it to be useful to others, or even to your future self\footnote{I continue to learn this the hard way with my own code.}.
Commenting your code is the standard way to explain the choices that you made in order to accomplish your goal.  

There is some guidance to get started with official explanations of your classes and functions, which are typically called ``docstrings:'' \url{https://www.python.org/dev/peps/pep-0257/}.

\section{Namespaces and Modules}

	\subsection{Built-in Namespace}

	\subsection{\texttt{numpy}}
	
	\subsection{\texttt{matplotlib}}
	
	
\section{Jupyter Tricks}

For now, see \url{https://www.dataquest.io/blog/jupyter-notebook-tips-tricks-shortcuts/}.
%things like %matplotlib inline, default directory, etc.

\section{Next Steps}	

%
%One way of accomplishing this task in Python is a built-in function called ``range'':
%\begin{minted}{python}
%In[1]: range(10)
%Out[1]: [0,1,2,3,4,5,6,7,8,9]
%\end{minted}


\end{document}
